/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   gnlcomment.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tchariss <tchariss@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/12/01 16:27:13 by tchariss          #+#    #+#             */
/*   Updated: 2020/12/07 12:28:54 by tchariss         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>
#include <stdlib.h> 
#include <stdio.h>
#include <fcntl.h> // open
#include "strdup.c"
#include "strjoin.c"
#include "strchr.c"
#include "strnew.c"
#include "strcpy.c"

char 	*check_rem(char *remember, char **line)
{
	char	*new_line; // переменная, куда сохраним указатель на новую линию

	new_line = NULL;
	if (remember != NULL) // если remember не пустой 
	{ // будем копировать ( в зависимости от того есть ли новая линия или нет )
		if ((new_line = strchr(remember, '\n'))) 
		// if strchr - если найдем в remember новую линию, то
		// В new_line - кладется на новую линию, если нет , то просто ноль
		// Нам нужно все, что до новой линии -> скопировать в line, а после -> вернуть в remember
		{
			*new_line = '\0'; // останавливаем копирование, то есть всё до '\0'(конца строки)
			*line = strdup(remember); // скопируем все что "до" в line
			//new_line++;
			strcopy(remember, ++new_line); // копируем из new_line в remember 
			// пропускаем(делаем сдвиг) конец строки (копировать все поле него) -> поэтому ++line ()
			// strcpy - копирует содержимое из s2 в s1 ( без выделения памяти )
			// до тех пор, пока не встречает '\0'
		} // -> нашли, прочитали и записали строку
		else // если не встретили новую линию, то копируем все, что было
		{ 
			*line = strdup(remember);
			//clear(remember); // очистка всего, что там было
		}
	}
	else // если в remember ничего нет 
	{
		*line = strdup("");// Иницициализируем переменную, чтобы не было мусора // Создаем line новую локацию памяти
	}
	return (new_line); // Возвращаем указатель new_line 
	// Если new_line нулевой, то нам нужно что-то читать
	// Если не нулевой , то читать ничего не нужно (в g_n_l -> read ..)
}

// Ф-ия GNL записывает в *line считанную из fd строку до первого символа \n
int	get_next_line(int fd, char **line) // line - буква, *line - строка(линия), **line - адрес строки
/*
	1 - строка прочитана и конец файла не достигнут -> в line записывается новая строка
	0 - line прочитана, строка записана и файл закончился
	-1 - любые ошибки (много памяти , fd испорчен , line == null и тд)
*/
{	// Создадим буффер на какое-то количество символов ( место для временного хранения данных )
	char		buf[1000 + 1]; // сюда записываются 10 символ после read
	// Нумерация массива с 0 , поэтому read вернет 10, номер последней буквы в массиве 9 -> 
	// "+ 1" - всего 10 элементов + 1 , 10-м номером устанавливаем '\0'
	int			readbyte; // переменная, в которую 
	char		*point_n; // указатель на '\n'
	int			stop; // - для остановки цикла 
	static char	*remember; // запомнить остаток, который после '\0 '
	
	stop = 1;
	point_n = check_rem(remember, line); // может вернуть 0, тогда нужно читать, если нет то не нужно читать
	// check_rem(remember, line); // вызываем функцию , которая заменит ниже сказанное закомментированное
	// point_n = NULL; // инициализируем , т.к. может быть чем угодно
		// if (remember != NULL) // если остаток существует(не равен нулю)
		// 	*line = strdup(remember); // тогда запишем и добавим это в line
		// else // если ничего не было, то инициализруем новой линией
		// 	*line = strdup(""); // чтобы вначале исчез мусор ( =strnew(1) || = "\0" || strdup(" ") )
		// strnew -  заполняет строку нулями и то количество, которое просим
	while (point_n == 0 && stop != 0 && (readbyte = read(fd, buf, 1000))) //все ф-ям со строками необходим конец строки '\0' // и пока stop != null
	// Пока point_n нулевой мы читаем, если не равен 0, то цикл нужно остановить
	// Read - возвращает количество прочитанных байт
	// из fd будем читать 10 символов за раз, начиная с buf
	{ 
		buf[readbyte] = '\0';
		if ((point_n = strchr(buf, '\n')))
		// strchr - ищет первое вхождение '\n' в строке , на которую указывает buf и пишет с '\n' и далее
		{
			*point_n = '\0';// \n -> в \0//до '\n' нужно все скопировать в line
			// теперь buf это строка до '\0', но цикл не остановится потому что нам есть что дальше читать
			stop = 0; // портим условие , stop остановит цикл и строка прочитается до конца 
			// break; // принудительное окончание цикла
			point_n++; // сдвинуть указатель на 1 ячейку вперед, чтобы пропустить '\0'
			remember = strdup(point_n); // Скопируем строку из point_n в remember // Запишется все, что после '\0'
		}
		// *line = strdup(buf);// cкопируем символы из buf в line 
		*line = strjoin(*line, buf); // Запишется : всё, что до '\0'
	}
	return (0);	
}

int main()
{
	char *line;
	int fd;
	
	fd = open("file.txt", O_RDONLY); // fd(1,2) -> 1 - имя файла, 2 - (флаги) как его будем открывать :
	// O_RDONLY - только для чтения, O_WRONLY - только для записи, O_RDWR - для чтения и записи
	get_next_line(fd, &line);
	printf("%s\n", line);
	get_next_line(fd, &line); // читаем 2 строку
	printf("%s\n", line);
	get_next_line(fd, &line); // 3 строка
	printf("%s\n", line);
	get_next_line(fd, &line); // 4 строка
	printf("%s\n", line);
}

//  в конце можно сократить названия переменных