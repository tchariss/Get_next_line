/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   gnlcom(2)correct.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tchariss <tchariss@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/12/01 16:27:13 by tchariss          #+#    #+#             */
/*   Updated: 2020/12/10 12:04:31 by tchariss         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <unistd.h>
#include <stdlib.h> 
#include <stdio.h>
#include <fcntl.h> // open
#include "strdup.c"
#include "strjoin.c"
#include "strchr.c"
#include "strnew.c"
#include "strcpy.c"
#include "strclear.c"

// #include <fcntl.h> // open
// #include <stdio.h> // printf

// #include "get_next_line.h" // - включить созданную библиотеку 

char 	*check_rem(char *remember, char **line)
{
	char	*new_line; // переменная, куда сохраним указатель на новую линию

	new_line = NULL;
	if (remember != NULL) // если remember не пустой 
// будем копировать ( в зависимости от того есть ли новая линия или нет )
		if ((new_line = strchr(remember, '\n'))) 
		// if strchr - если найдем в remember новую линию, то
		// В new_line - кладется на новую линию, если нет , то просто ноль
		// Нам нужно все, что до новой линии -> скопировать в line, а после -> вернуть в remember
		{
			*new_line = '\0'; // останавливаем копирование, то есть всё до '\0'(конца строки)
			*line = strdup(remember); // скопируем все что "до" в line
			//new_line++;
			strcopy(remember, ++new_line); // копируем из new_line в remember 
			// пропускаем(делаем сдвиг) конец строки (копировать все поле него) -> поэтому ++line ()
			// strcpy - копирует содержимое из s2 в s1 ( без выделения памяти )
			// до тех пор, пока не встречает '\0'
		} // -> нашли, прочитали и записали строку
		else // если не встретили новую линию, то копируем все, что было
		{ 
			*line = strdup(remember);
			// strdup - возвращает указатель на новую строку
			strclear(remember); // очистка всего, что там было
		}
	else // если в remember ничего нет 
		*line = strdup(""); // Иницициализируем переменную, чтобы не было мусора 
 // создаем line новую локацию памяти 
	return (new_line); // Возвращаем указатель new_line 
	// Если new_line нулевой, то нам нужно что-то читать
	// Если не нулевой , то читать ничего не нужно (в g_n_l -> read ..)
}

// Ф-ия GNL записывает в *line считанную из fd строку до первого символа \n
int	get_next_line(int fd, char **line) // line - буква, *line - строка(линия), **line - адрес строки
/*
	// RETURN : 1 - строка прочитана и конец файла не достигнут -> в line записывается новая строка
	// 0 - line прочитана, строка записана и файл закончился (Чтение файла завершено)
	// -1 - любые ошибки (много памяти , fd испорчен , line == null и тд
*/
{	// Создадим буффер на какое-то количество символов ( место для временного хранения данных )
	char		buf[10 + 1]; // сюда записываются 10 символ после read
	// Нумерация массива с 0 , поэтому read вернет 10, номер последней буквы в массиве 9 -> 
	// "+ 1" - всего 10 элементов + 1 , 10-м номером устанавливаем '\0'
	int			readbyte; // переменная, в которую записываю количество символов в строке(после read)
	char		*point_n; // указатель на '\n'
	int			stop; // - для остановки цикла 
	static char	*remember; // запомнить остаток, который после '\0 '
	char		*timevar; //временная переменная

	stop = 1;
	point_n = check_rem(remember, line); // может вернуть 0, тогда нужно читать, если нет то не нужно читать
	// check_rem(remember, line); // вызываем функцию , которая заменит ниже сказанное закомментированное
	// point_n = NULL; // инициализируем , т.к. может быть чем угодно
		// if (remember != NULL) // если остаток существует(не равен нулю)
		// 	*line = strdup(remember); // тогда запишем и добавим это в line
		// else // если ничего не было, то инициализруем новой линией
		// 	*line = strdup(""); // чтобы вначале исчез мусор ( =strnew(1) || = "\0" || strdup(" ") )
		// strnew -  заполняет строку нулями и то количество, которое просим
	while (point_n == 0 && stop != 0 && (readbyte = read(fd, buf, 10))) //все ф-ям со строками необходим конец строки '\0' // и пока stop != null
// Read - возвращает количество действительно считанных байт
	// Пока point_n нулевой мы читаем, если не равен 0, то цикл нужно остановить
	// Read - возвращает количество прочитанных байт
	// из fd будем читать 10 символов за раз, начиная с buf
	{ 
		buf[readbyte] = '\0';
// (1) - файловый описатель(название) откуда все будет браться - (fd)
// (2) - аргумент(адрес) указывающий на файл - (buf)
// (3) - сколько количество байт нужно считывать из файла - (BUFFER_SIZE)
		if ((point_n = strchr(buf, '\n')))
		// strchr - ищет первое вхождение '\n' в строке , на которую указывает buf и пишет с '\n' и далее
		{
			*point_n = '\0';// \n -> в \0//до '\n' нужно все скопировать в line
			// теперь buf это строка до '\0', но цикл не остановится потому что нам есть что дальше читать
			stop = 0; // портим условие , stop остановит цикл и строка прочитается до конца 
			// break; // принудительное окончание цикла
			point_n++; // сдвинуть указатель на 1 ячейку вперед, чтобы пропустить '\0'
			remember = strdup(point_n); // Скопируем строку из point_n в remember // Запишется все, что после '\0'
		}
		// *line = strdup(buf);// cкопируем символы из buf в line в переменную
		timevar = *line; // сохраним старое значение line
		*line = strjoin(*line, buf); //копируем прочитанное из buf в line || дублируем строку buf в line
// Запишется : всё, что до '\0'
		free(timevar); //очищение старого зачения *line
		// когда копируем последнюю часть из остатка и очищаем -> было что читать 
	}
	if ((readbyte != 0) || (strlen(remember) != 0) || (strlen(*line) != 0))
		return (1); // если что-то было прочитано
	return (0); // если файл закончился
	// Если readbyte не равно 0, значит что-то было прочитано или
	// Длина remember не равно 0, значит есть что читать 
	// Если длина *line не равно 0, значит что-то было записано и мы возвращаем не 0
		// (Чтобы последняя строка считалась и записалась)
}

int	main(void)
{
    int fd;
    char **line;
    int ret;

    fd = open("file.txt", O_RDONLY);
    if (!(line = (char **)malloc(sizeof(char*) * 10000)))
        return (0);

    while ((ret = get_next_line(fd, line)) > 0)
    {
        printf("%s\n", *line);
        printf("%i\n", ret);
        free(*line);
    }
    printf("%s\n", *line);
    printf("%i\n", ret);
    free(line);
    return(0);
}
// int main()
// {
// 	char *line;
// 	int fd;
	
// 	fd = open("file.txt", O_RDONLY); // fd(1,2) -> 1 - имя файла, 2 - (флаги) как его будем открывать :
// 	// O_RDONLY - только для чтения, O_WRONLY - только для записи, O_RDWR - для чтения и записи
// 	while (get_next_line(fd, &line))
// 		printf("%s\n", line);
// }

//  в конце можно сократить названия переменных